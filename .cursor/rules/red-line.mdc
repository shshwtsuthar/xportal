---
alwaysApply: true
---

# Always Follow These Rules

# -------------------------------------------
# 1. Core Philosophy & Tech Stack
# -------------------------------------------
- The database schema is the absolute single source of truth for this project. All code serves the data model.
- Follow a strict "Backend-First" development flow: Database -> API/Hooks -> UI.
- The tech stack is: Next.js (App Router), Supabase (Postgres, Auth, Edge Functions), TypeScript, ShadCN for UI, TanStack Query for server state, and Playwright for E2E testing.

# -------------------------------------------
# 2. Database & Migrations
# -------------------------------------------
- Database schema changes are **always** done via Supabase migration files. Never suggest altering the schema directly through the UI.
- The workflow for a schema change is:
  1. `supabase migration new "feature-name"`
  2. Write the SQL.
  3. `supabase db reset` to apply locally.
- After every successful migration, the immediate next step is to regenerate the TypeScript types.

# -------------------------------------------
# 3. Type Safety (Non-Negotiable)
# -------------------------------------------
- The `database.types.ts` file is the single source of truth for all database-related types.
- Always import database types using the pattern: `import { Tables, Enums } from '@/database.types';`.
- **Never** create redundant frontend types that duplicate what's in `database.types.ts`.
- Derive component prop types directly from the base `Tables` types. For example:
  ```typescript
  // Correct way to define props
  type ProfileCardProps = {
    profile: Tables<'profiles'>;
  };
  ```
- Regenerate types after every migration with the command: `supabase gen types typescript --local > database.types.ts`.

# -------------------------------------------
# 4. API & Data Fetching (TanStack Query Hooks)
# -------------------------------------------
- Use TanStack Query (`@tanstack/react-query`) for all server state management (fetching, caching, updating).
- **For fetching data (Reads):** Use the `useQuery` hook following this exact pattern:
  - The `queryKey` must be a descriptive array, typically `['entityName', entityId]`. Example: `queryKey: ['profile', userId]`.
  - The `queryFn` must be an `async` function that uses the `supabase-js` client.
  - The `queryFn` must include robust error handling: `if (error) { throw new Error(error.message); }`.
- **For mutating data (Writes):** Use the `useMutation` hook following this exact pattern:
  - The `mutationFn` is an `async` function that takes the payload (e.g., `updatedProfileData`) and performs the `insert`, `update`, or `delete` operation.
  - Use the `onSuccess` callback to invalidate relevant queries using `queryClient.invalidateQueries()`. This is critical for keeping the UI in sync.
  - Use the `onError` callback to display an error notification to the user.
- Place all reusable TanStack Query hooks in the `src/hooks/` directory, with filenames like `useGetEntity.ts` or `useUpdateEntity.ts`.

# -------------------------------------------
# 5. UI & Components (ShadCN)
# -------------------------------------------
- All UI components must be built using components from the **ShadCN** library.
- Components should be "dumb" whenever possible. They receive data and callbacks as props from parent components or pages.
- Strictly separate server state from client state. Use TanStack Query for data from the database. Use `useState` or `useReducer` only for UI-specific state (e.g., form input values, modal visibility).
- For user feedback after mutations, always use the `sonner` component to display toast notifications (e.g., "Profile updated successfully!").

# -------------------------------------------
# 6. Code Style & Comments
# -------------------------------------------
- Add JSDoc comments to all hooks and complex functions, explaining their purpose, `@param`, and `@returns`.
- Any field, function, or validation logic that is directly related to **AVETMISS compliance** must be explicitly commented. For example:
  ```typescript
  // NAT00080: Client Gender. Must conform to AVETMISS standard codes.
  const gender = formData.get('gender');
  ```
- Use `// TODO:` to flag incomplete work or areas that need further attention.

# -------------------------------------------
# 7. Human-Controlled Tasks
# -------------------------------------------
- I, the developer, am solely responsible for writing and running tests using **Playwright**. Do not write test files unless explicitly asked.
- I, the developer, am solely responsible for **Git commits**. Do not perform commits. I will handle version control after verifying the feature and its tests.