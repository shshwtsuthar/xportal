/// <reference lib="deno.ns" />

import { serve } from 'std/http/server.ts';
import { createClient } from '@supabase/supabase-js';
import { Database } from '../_shared/database.types.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
};

type Db = Database;

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  const supabase = createClient<Db>(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SUPABASE_ANON_KEY') ?? '',
    {
      global: {
        headers: { Authorization: req.headers.get('Authorization')! },
      },
    }
  );

  // Service role client for storage operations that bypass RLS
  const service = createClient<Db>(
    Deno.env.get('SUPABASE_URL') ?? '',
    Deno.env.get('SERVICE_ROLE_KEY') ?? ''
  );

  const { applicationId } = await req.json();
  if (!applicationId) {
    return new Response(
      JSON.stringify({ error: 'applicationId is required' }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }

  // Fetch application with needed fields
  const { data: app, error: appErr } = await supabase
    .from('applications')
    .select('*')
    .eq('id', applicationId)
    .single();
  if (appErr || !app) {
    return new Response(JSON.stringify({ error: 'Application not found' }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 404,
    });
  }

  if (app.status === 'ARCHIVED') {
    return new Response(
      JSON.stringify({
        error: 'Archived applications cannot be approved or edited.',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 409,
      }
    );
  }

  if (app.status !== 'ACCEPTED') {
    return new Response(
      JSON.stringify({
        error: `Application must be ACCEPTED to approve. Current: ${app.status}`,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 409,
      }
    );
  }

  // Payment plan template and anchor date are required
  if (!app.payment_plan_template_id) {
    return new Response(
      JSON.stringify({
        error: 'payment_plan_template_id is required',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }

  if (!app.payment_anchor_date) {
    return new Response(
      JSON.stringify({
        error: 'payment_anchor_date is required',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }

  const { data: template, error: tplErr } = await supabase
    .from('payment_plan_templates')
    .select('id')
    .eq('id', app.payment_plan_template_id)
    .single();
  if (tplErr || !template) {
    return new Response(
      JSON.stringify({ error: 'Payment plan template not found' }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }

  // Use the required payment anchor date
  const anchorDate = app.payment_anchor_date as string;

  if (!anchorDate) {
    return new Response(
      JSON.stringify({
        error: 'Anchor date cannot be determined for template',
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }

  // Begin approval transaction using PostgREST sequential operations
  // 1) Create student (or fetch existing if already created - idempotent)
  // Note: student_id_display will be auto-generated by trigger if empty/null
  // TypeScript types mark it as required, but the database trigger handles empty strings

  // Check if student already exists for this application (idempotency)
  let student: Db['public']['Tables']['students']['Row'] | null = null;
  const { data: existingStudent, error: checkErr } = await supabase
    .from('students')
    .select('*')
    .eq('application_id', app.id)
    .maybeSingle();

  if (checkErr) {
    console.error('Error checking for existing student:', checkErr);
    return new Response(
      JSON.stringify({
        error: 'Failed to check for existing student',
        details: checkErr.message,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }

  if (existingStudent) {
    // Student already exists - use it (idempotent behavior)
    console.log(
      `Student already exists for application ${app.id}, using existing student ${existingStudent.id}`
    );
    student = existingStudent;
  } else {
    // Create new student
    const studentInsert = {
      rto_id: app.rto_id,
      application_id: app.id,
      salutation: app.salutation,
      first_name: app.first_name!,
      middle_name: app.middle_name,
      last_name: app.last_name!,
      preferred_name: app.preferred_name,
      email: app.email!,
      date_of_birth: app.date_of_birth!,
      work_phone: app.work_phone,
      mobile_phone: app.mobile_phone,
      alternative_email: app.alternative_email,
      status: 'ACTIVE',
      // Pass empty string - trigger will generate the actual display ID
      student_id_display: '',
    } as Db['public']['Tables']['students']['Insert'];

    const { data: newStudent, error: studentErr } = await supabase
      .from('students')
      .insert(studentInsert)
      .select('*')
      .single();

    if (studentErr || !newStudent) {
      console.error('Student creation error:', studentErr);
      return new Response(
        JSON.stringify({
          error: 'Failed to create student',
          details: studentErr?.message || 'Unknown error',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }
    student = newStudent;
  }

  // 1b) Copy files from applications bucket to students bucket
  const fileCopyWarnings: string[] = [];
  try {
    // Recursively list all files in the application folder
    const listFilesRecursively = async (
      bucket: string,
      prefix: string,
      files: string[] = []
    ): Promise<string[]> => {
      const { data, error } = await service.storage.from(bucket).list(prefix, {
        limit: 1000,
        sortBy: { column: 'name', order: 'asc' },
      });

      if (error) {
        console.error(`Error listing files in ${prefix}:`, error);
        return files;
      }

      if (!data || data.length === 0) {
        return files;
      }

      for (const item of data) {
        const fullPath = prefix ? `${prefix}/${item.name}` : item.name;
        // Files have an id property, folders don't
        if (item.id) {
          // It's a file
          files.push(fullPath);
        } else {
          // It's a folder, recurse into it
          await listFilesRecursively(bucket, fullPath, files);
        }
      }

      return files;
    };

    const applicationFiles = await listFilesRecursively('applications', app.id);

    // Copy each file to students bucket
    for (const filePath of applicationFiles) {
      try {
        // Download from applications bucket
        const { data: fileData, error: downloadErr } = await service.storage
          .from('applications')
          .download(filePath);

        if (downloadErr || !fileData) {
          fileCopyWarnings.push(
            `Failed to download ${filePath}: ${downloadErr?.message || 'Unknown error'}`
          );
          continue;
        }

        // Calculate relative path (remove applicationId prefix)
        const relativePath = filePath.startsWith(`${app.id}/`)
          ? filePath.slice(`${app.id}/`.length)
          : filePath;

        // Upload to students bucket
        const targetPath = `${student.id}/${relativePath}`;
        // Get content type from file extension or metadata if available
        const contentType = fileData.type || undefined;
        const { error: uploadErr } = await service.storage
          .from('students')
          .upload(targetPath, fileData, {
            contentType: contentType,
            upsert: false,
          });

        if (uploadErr) {
          fileCopyWarnings.push(
            `Failed to upload ${targetPath}: ${uploadErr.message}`
          );
        }
      } catch (fileErr) {
        fileCopyWarnings.push(
          `Error copying ${filePath}: ${fileErr instanceof Error ? fileErr.message : String(fileErr)}`
        );
      }
    }
  } catch (copyErr) {
    // Log error but don't fail approval
    console.error('Error during file copy:', copyErr);
    fileCopyWarnings.push(
      `File copy operation failed: ${copyErr instanceof Error ? copyErr.message : String(copyErr)}`
    );
  }

  // 2) Create enrollment and copy template id (idempotent check)
  if (!app.program_id) {
    return new Response(
      JSON.stringify({ error: 'Application program_id is required' }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 400,
      }
    );
  }

  // Check if enrollment already exists for this student and program
  let enrollment: Db['public']['Tables']['enrollments']['Row'] | null = null;
  const { data: existingEnrollment, error: checkEnrErr } = await supabase
    .from('enrollments')
    .select('*')
    .eq('student_id', student.id)
    .eq('program_id', app.program_id)
    .maybeSingle();

  if (checkEnrErr) {
    return new Response(
      JSON.stringify({
        error: 'Failed to check for existing enrollment',
        details: checkEnrErr.message,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }

  if (existingEnrollment) {
    // Enrollment already exists - use it (idempotent behavior)
    console.log(
      `Enrollment already exists for student ${student.id} and program ${app.program_id}, using existing enrollment ${existingEnrollment.id}`
    );
    enrollment = existingEnrollment;
  } else {
    // Create new enrollment
    const { data: newEnrollment, error: enrErr } = await supabase
      .from('enrollments')
      .insert({
        student_id: student.id,
        program_id: app.program_id,
        rto_id: app.rto_id,
        status: 'ACTIVE',
        commencement_date: anchorDate,
        payment_plan_template_id: app.payment_plan_template_id,
      })
      .select('*')
      .single();
    if (enrErr || !newEnrollment) {
      return new Response(
        JSON.stringify({
          error: 'Failed to create enrollment',
          details: enrErr?.message || 'Unknown error',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }
    enrollment = newEnrollment;
  }

  // 3) Use application_payment_schedule snapshot if present; fallback to on-the-fly calc.
  //    Always create invoices as SCHEDULED and attach at least one invoice_lines row per invoice.
  //    Check if invoices already exist for this enrollment (idempotency)
  let existingInvoices: Db['public']['Tables']['invoices']['Row'][] = [];
  const { data: existingInvoicesData, error: checkInvErr } = await supabase
    .from('invoices')
    .select('*')
    .eq('enrollment_id', enrollment.id);

  if (checkInvErr) {
    return new Response(
      JSON.stringify({
        error: 'Failed to check for existing invoices',
        details: checkInvErr.message,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }

  if (existingInvoicesData && existingInvoicesData.length > 0) {
    // Invoices already exist - use them (idempotent behavior)
    console.log(
      `Invoices already exist for enrollment ${enrollment.id}, using ${existingInvoicesData.length} existing invoices`
    );
    existingInvoices = existingInvoicesData;
  }

  const { data: snapshot, error: snapErr } = await supabase
    .from('application_payment_schedule')
    .select('id, name, amount_cents, due_date, template_installment_id')
    .eq('application_id', app.id)
    .order('sequence_order', { ascending: true })
    .order('due_date', { ascending: true })
    .order('name', { ascending: true });

  const todayIso = new Date().toISOString().slice(0, 10);

  const requestInvoiceNumber = async (issueDate: string) => {
    const seed = crypto.randomUUID();
    const { data, error } = await supabase.rpc('generate_invoice_number', {
      p_created: issueDate,
      p_uuid: seed,
    });
    if (error || !data) {
      throw new Error(error?.message || 'Failed to generate invoice number');
    }
    return data as string;
  };

  let invoiceRows: Db['public']['Tables']['invoices']['Insert'][] = [];
  const invoiceLineTemplates: {
    invoice_number: string;
    name: string;
    amount_cents: number;
    sequence_order: number;
    is_commissionable: boolean;
    description: string | null;
    xero_account_code: string | null;
    xero_tax_type: string | null;
    xero_item_code: string | null;
  }[] = [];

  if (!snapErr && snapshot && snapshot.length > 0) {
    const { data: snapshotLines, error: snapLinesErr } = await supabase
      .from('application_payment_schedule_lines')
      .select(
        'application_payment_schedule_id, name, description, amount_cents, sequence_order, is_commissionable, xero_account_code, xero_tax_type, xero_item_code'
      )
      .eq('application_id', app.id)
      .order('application_payment_schedule_id', { ascending: true })
      .order('sequence_order', { ascending: true });

    if (snapLinesErr) {
      return new Response(
        JSON.stringify({
          error: 'Failed to read payment schedule lines snapshot',
          details: snapLinesErr.message,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    const snapshotLinesMap = new Map<
      string,
      Array<{
        name: string;
        description: string | null;
        amount_cents: number;
        sequence_order: number;
        is_commissionable: boolean;
        xero_account_code: string | null;
        xero_tax_type: string | null;
        xero_item_code: string | null;
      }>
    >();

    (snapshotLines ?? []).forEach((line) => {
      const schedId = line.application_payment_schedule_id as string;
      if (!snapshotLinesMap.has(schedId)) {
        snapshotLinesMap.set(schedId, []);
      }
      snapshotLinesMap.get(schedId)!.push({
        name: line.name,
        description: line.description,
        amount_cents: line.amount_cents,
        sequence_order: line.sequence_order,
        is_commissionable: line.is_commissionable,
        xero_account_code: line.xero_account_code,
        xero_tax_type: line.xero_tax_type,
        xero_item_code: line.xero_item_code,
      });
    });

    const rows: Db['public']['Tables']['invoices']['Insert'][] = [];

    for (let idx = 0; idx < snapshot.length; idx++) {
      const row = snapshot[idx];
      const amountCents = row.amount_cents as number;
      const schedId = row.id as string;
      const issueDate =
        idx === 0 ? todayIso : ((row.due_date as string) ?? todayIso);

      let invoiceNumber: string;
      try {
        invoiceNumber = await requestInvoiceNumber(issueDate);
      } catch (invNumErr) {
        console.error(
          'Failed to generate invoice number (snapshot path):',
          invNumErr
        );
        return new Response(
          JSON.stringify({
            error: 'Failed to generate invoice number',
            details:
              invNumErr instanceof Error
                ? invNumErr.message
                : String(invNumErr),
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }

      // Get snapshot lines for this installment, or create a fallback line if none exist
      const linesForInstallment = snapshotLinesMap.get(schedId) ?? [];

      if (linesForInstallment.length > 0) {
        linesForInstallment.forEach((line) => {
          invoiceLineTemplates.push({
            invoice_number: invoiceNumber,
            name: line.name,
            amount_cents: line.amount_cents,
            sequence_order: line.sequence_order,
            is_commissionable: line.is_commissionable,
            description: line.description,
            xero_account_code: line.xero_account_code,
            xero_tax_type: line.xero_tax_type,
            xero_item_code: line.xero_item_code,
          });
        });
      } else {
        invoiceLineTemplates.push({
          invoice_number: invoiceNumber,
          name: row.name ?? `Installment ${idx + 1}`,
          amount_cents: amountCents,
          sequence_order: idx,
          is_commissionable: false,
          description: null,
          xero_account_code: null,
          xero_tax_type: null,
          xero_item_code: null,
        });
      }

      rows.push({
        enrollment_id: enrollment.id,
        rto_id: app.rto_id,
        status: 'SCHEDULED',
        invoice_number: invoiceNumber,
        issue_date: issueDate,
        due_date: row.due_date as string,
        amount_due_cents: amountCents,
        amount_paid_cents: 0,
      } as Db['public']['Tables']['invoices']['Insert']);
    }

    invoiceRows = rows;
  } else {
    // Fallback: compute based on template installments and anchor
    const { data: installments, error: instErr } = await supabase
      .from('payment_plan_template_installments')
      .select('id, name, amount_cents, due_date_rule_days, is_commissionable')
      .eq('template_id', template.id)
      .order('due_date_rule_days', { ascending: true });
    if (instErr) {
      return new Response(
        JSON.stringify({ error: 'Failed to read installments' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    // Fetch lines for each installment
    const installmentIds = (installments ?? []).map((i) => i.id);
    const { data: installmentLines, error: linesErr } = await supabase
      .from('payment_plan_template_installment_lines')
      .select('*')
      .in('installment_id', installmentIds)
      .order('installment_id', { ascending: true })
      .order('sequence_order', { ascending: true });

    if (linesErr) {
      return new Response(
        JSON.stringify({ error: 'Failed to read installment lines' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    // Group lines by installment_id
    const linesByInstallment = new Map<string, typeof installmentLines>();
    (installmentLines ?? []).forEach((line) => {
      const instId = line.installment_id;
      if (!linesByInstallment.has(instId)) {
        linesByInstallment.set(instId, []);
      }
      linesByInstallment.get(instId)!.push(line);
    });

    const anchor = new Date(anchorDate);
    const rows: Db['public']['Tables']['invoices']['Insert'][] = [];
    const safeInstallments = installments ?? [];

    for (let idx = 0; idx < safeInstallments.length; idx++) {
      const installment = safeInstallments[idx];
      const due = new Date(anchor);
      due.setDate(due.getDate() + Number(installment.due_date_rule_days));
      const dueDateStr = due.toISOString().slice(0, 10);
      const issueDate = idx === 0 ? todayIso : dueDateStr;
      const amountCents = installment.amount_cents as number;

      let invoiceNumber: string;
      try {
        invoiceNumber = await requestInvoiceNumber(issueDate);
      } catch (invNumErr) {
        console.error(
          'Failed to generate invoice number (template path):',
          invNumErr
        );
        return new Response(
          JSON.stringify({
            error: 'Failed to generate invoice number',
            details:
              invNumErr instanceof Error
                ? invNumErr.message
                : String(invNumErr),
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }

      const lines = linesByInstallment.get(installment.id) ?? [];
      if (lines.length > 0) {
        lines.forEach((line) => {
          invoiceLineTemplates.push({
            invoice_number: invoiceNumber,
            name: line.name,
            amount_cents: line.amount_cents,
            sequence_order: line.sequence_order,
            is_commissionable: line.is_commissionable,
            description: line.description ?? null,
            xero_account_code: line.xero_account_code ?? null,
            xero_tax_type: line.xero_tax_type ?? null,
            xero_item_code: line.xero_item_code ?? null,
          });
        });
      } else {
        invoiceLineTemplates.push({
          invoice_number: invoiceNumber,
          name: installment.name ?? `Installment ${idx + 1}`,
          amount_cents: amountCents,
          sequence_order: idx,
          is_commissionable: Boolean(
            (installment as { is_commissionable?: boolean }).is_commissionable
          ),
          description: null,
          xero_account_code: null,
          xero_tax_type: null,
          xero_item_code: null,
        });
      }

      rows.push({
        enrollment_id: enrollment.id,
        rto_id: app.rto_id,
        status: 'SCHEDULED',
        invoice_number: invoiceNumber,
        issue_date: issueDate,
        due_date: dueDateStr,
        amount_due_cents: amountCents,
        amount_paid_cents: 0,
      } as Db['public']['Tables']['invoices']['Insert']);
    }

    invoiceRows = rows;
  }

  // Only create invoices if they don't already exist (idempotency)
  let insertedInvoices: Array<{ id: string; invoice_number: string }> = [];
  if (existingInvoices.length > 0) {
    // Use existing invoices
    insertedInvoices = existingInvoices.map((inv) => ({
      id: inv.id,
      invoice_number: inv.invoice_number,
    }));
    console.log(
      `Using ${insertedInvoices.length} existing invoices for enrollment ${enrollment.id}`
    );
  } else if (invoiceRows.length > 0) {
    // Create new invoices
    const { data: newInvoices, error: invErr } = await supabase
      .from('invoices')
      .insert(invoiceRows)
      .select('id, invoice_number');
    if (invErr || !newInvoices) {
      return new Response(
        JSON.stringify({
          error: 'Failed to create invoices',
          details: invErr?.message || 'Unknown error',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }
    insertedInvoices = newInvoices;
  }

  // Insert one invoice_lines row per invoice based on the templates prepared above.
  // Only create invoice_lines if invoices were just created (not if using existing invoices)
  if (existingInvoices.length === 0 && invoiceLineTemplates.length > 0) {
    const invoiceLines: Db['public']['Tables']['invoice_lines']['Insert'][] =
      [];

    for (const tpl of invoiceLineTemplates) {
      const invoice = insertedInvoices.find(
        (inv) => inv.invoice_number === tpl.invoice_number
      );
      if (!invoice) continue;

      invoiceLines.push({
        invoice_id: invoice.id,
        name: tpl.name,
        description: tpl.description,
        amount_cents: tpl.amount_cents,
        sequence_order: tpl.sequence_order,
        is_commissionable: tpl.is_commissionable,
        xero_account_code: tpl.xero_account_code,
        xero_tax_type: tpl.xero_tax_type,
        xero_item_code: tpl.xero_item_code,
      });
    }

    if (invoiceLines.length > 0) {
      const { error: lineErr } = await supabase
        .from('invoice_lines')
        .insert(invoiceLines);
      if (lineErr) {
        return new Response(
          JSON.stringify({
            error: 'Failed to create invoice lines',
            details: lineErr.message,
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  } else if (existingInvoices.length > 0) {
    console.log(
      `Skipping invoice_lines creation - using existing invoices with existing lines`
    );
  }

  // --- Extended copy: student domain normalization ---
  // 3b) Addresses (street + postal)
  {
    const street = {
      student_id: student.id,
      rto_id: app.rto_id,
      type: 'street',
      building_name: app.street_building_name,
      unit_details: app.street_unit_details,
      number_name: app.street_number_name,
      po_box: app.street_po_box,
      suburb: app.suburb,
      state: app.state,
      postcode: app.postcode,
      country: app.street_country,
      is_primary: true,
    } as const;
    const postal = app.postal_is_same_as_street
      ? null
      : {
          student_id: student.id,
          rto_id: app.rto_id,
          type: 'postal',
          building_name: app.postal_building_name,
          unit_details: app.postal_unit_details,
          number_name: app.postal_number_name,
          po_box: app.postal_po_box,
          suburb: app.postal_suburb,
          state: app.postal_state,
          postcode: app.postal_postcode,
          country: app.postal_country,
          is_primary: false,
        };
    const addrRows = [street, postal].filter(
      Boolean
    ) as Db['public']['Tables']['student_addresses']['Insert'][];
    if (addrRows.length > 0) {
      const { error: addrErr } = await supabase
        .from('student_addresses')
        .insert(addrRows);
      if (addrErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy student addresses' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  }

  // 3c) AVETMISS snapshot
  {
    const { error: avErr } = await supabase.from('student_avetmiss').insert({
      student_id: student.id,
      rto_id: app.rto_id,
      gender: app.gender,
      highest_school_level_id: app.highest_school_level_id,
      year_highest_school_level_completed:
        app.year_highest_school_level_completed,
      indigenous_status_id: app.indigenous_status_id,
      labour_force_status_id: app.labour_force_status_id,
      country_of_birth_id: app.country_of_birth_id,
      language_code: app.language_code,
      citizenship_status_code: app.citizenship_status_code,
      at_school_flag: app.at_school_flag,
      disability_flag: app.disability_flag || null,
      prior_education_flag: app.prior_education_flag || null,
      survey_contact_status: app.survey_contact_status || 'A',
      vsn: app.vsn || null,
      usi: app.usi || null,
    });
    if (avErr) {
      return new Response(
        JSON.stringify({ error: 'Failed to copy AVETMISS details' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }
  }

  // 3c1) Copy disabilities from application to student
  {
    const { data: appDisabilities, error: fetchErr } = await supabase
      .from('application_disabilities')
      .select('disability_type_id')
      .eq('application_id', app.id);

    if (fetchErr) {
      console.error('Error fetching application disabilities:', fetchErr);
      return new Response(
        JSON.stringify({ error: 'Failed to fetch application disabilities' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    if (appDisabilities && appDisabilities.length > 0) {
      const studentDisabilities = appDisabilities.map((d) => ({
        student_id: student.id,
        rto_id: app.rto_id,
        disability_type_id: d.disability_type_id,
      }));

      const { error: disErr } = await supabase
        .from('student_disabilities')
        .insert(studentDisabilities);
      if (disErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy disabilities' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  }

  // 3c2) Copy prior education from application to student
  {
    const { data: appPriorEd, error: fetchErr } = await supabase
      .from('application_prior_education')
      .select('prior_achievement_id, recognition_type')
      .eq('application_id', app.id);

    if (fetchErr) {
      console.error('Error fetching application prior education:', fetchErr);
      return new Response(
        JSON.stringify({
          error: 'Failed to fetch application prior education',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    if (appPriorEd && appPriorEd.length > 0) {
      const studentPriorEd = appPriorEd.map((e) => ({
        student_id: student.id,
        rto_id: app.rto_id,
        prior_achievement_id: e.prior_achievement_id,
        recognition_type: e.recognition_type || null,
      }));

      const { error: priorEdErr } = await supabase
        .from('student_prior_education')
        .insert(studentPriorEd);
      if (priorEdErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy prior education' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  }

  // 3d) CRICOS snapshot
  {
    const { error: crErr } = await supabase.from('student_cricos').insert({
      student_id: student.id,
      rto_id: app.rto_id,
      is_international: Boolean(app.is_international),
      passport_number: app.passport_number,
      passport_issue_date: app.passport_issue_date,
      passport_expiry_date: app.passport_expiry_date,
      place_of_birth: app.place_of_birth,
      visa_type: app.visa_type,
      visa_number: app.visa_number,
      visa_expiry_date: app.visa_expiry_date,
      visa_grant_date: app.visa_grant_date,
      visa_application_office: app.visa_application_office,
      holds_visa: app.holds_visa,
      country_of_citizenship: app.country_of_citizenship,
      coe_number: app.coe_number,
      is_under_18: app.is_under_18,
      provider_accepting_welfare_responsibility:
        app.provider_accepting_welfare_responsibility,
      welfare_start_date: app.welfare_start_date,
      provider_arranged_oshc: app.provider_arranged_oshc,
      oshc_provider_name: app.oshc_provider_name,
      oshc_policy_number: app.oshc_policy_number,
      oshc_start_date: app.oshc_start_date,
      oshc_end_date: app.oshc_end_date,
      has_english_test: app.has_english_test,
      english_test_type: app.english_test_type,
      english_test_date: app.english_test_date,
      ielts_score: app.ielts_score,
      has_previous_study_australia: app.has_previous_study_australia,
      previous_provider_name: app.previous_provider_name,
      completed_previous_course: app.completed_previous_course,
      has_release_letter: app.has_release_letter,
      privacy_notice_accepted: app.privacy_notice_accepted,
      written_agreement_accepted: app.written_agreement_accepted,
      written_agreement_date: app.written_agreement_date,
    });
    if (crErr) {
      return new Response(
        JSON.stringify({ error: 'Failed to copy CRICOS details' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }
  }

  // 3e) Emergency and guardian contacts
  {
    const inserts: Db['public']['Tables']['student_contacts_emergency']['Insert'][] =
      [];
    if (app.ec_name || app.ec_phone_number || app.ec_relationship) {
      if (!app.ec_name) {
        return new Response(
          JSON.stringify({
            error:
              'Emergency contact name is required when other emergency contact fields are provided',
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 400,
          }
        );
      }
      inserts.push({
        student_id: student.id,
        rto_id: app.rto_id,
        name: app.ec_name,
        relationship: app.ec_relationship,
        phone_number: app.ec_phone_number,
      });
    }
    if (inserts.length > 0) {
      const { error: ecErr } = await supabase
        .from('student_contacts_emergency')
        .insert(inserts);
      if (ecErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy emergency contacts' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
    if (app.g_name || app.g_email || app.g_phone_number) {
      if (!app.g_name) {
        return new Response(
          JSON.stringify({
            error:
              'Guardian contact name is required when other guardian contact fields are provided',
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 400,
          }
        );
      }
      const { error: gErr } = await supabase
        .from('student_contacts_guardians')
        .insert({
          student_id: student.id,
          rto_id: app.rto_id,
          name: app.g_name,
          email: app.g_email,
          phone_number: app.g_phone_number,
          relationship: app.g_relationship,
        });
      if (gErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy guardian contact' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  }

  // 3f) Learning plan subjects → enrollment_subjects
  {
    const { data: subjects, error: subjErr } = await supabase
      .from('application_learning_subjects')
      .select(
        'program_plan_subject_id, subject_id, planned_start_date, planned_end_date, is_catch_up, is_prerequisite'
      )
      .eq('application_id', app.id)
      .order('sequence_order', { ascending: true });
    if (!subjErr && subjects && subjects.length > 0) {
      const rows = subjects.map((s) => ({
        enrollment_id: enrollment.id,
        program_plan_subject_id: s.program_plan_subject_id,
        outcome_code: null,
        start_date: s.planned_start_date,
        end_date: s.planned_end_date,
        is_catch_up: s.is_catch_up,
        delivery_location_id: null,
        delivery_mode_id: null,
        scheduled_hours: null,
      }));
      const { error: insErr } = await supabase
        .from('enrollment_subjects')
        .insert(rows);
      if (insErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy enrollment subjects' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  }

  // 3g) Learning plan classes → enrollment_classes
  {
    const { data: classes, error: clsErr } = await supabase
      .from('application_learning_classes')
      .select(
        'program_plan_class_id, class_date, start_time, end_time, trainer_id, location_id, classroom_id, class_type'
      )
      .eq('application_id', app.id);
    if (!clsErr && classes && classes.length > 0) {
      const rows = classes.map((c) => ({
        enrollment_id: enrollment.id,
        program_plan_class_id: c.program_plan_class_id,
        class_date: c.class_date,
        start_time: c.start_time,
        end_time: c.end_time,
        trainer_id: c.trainer_id,
        location_id: c.location_id,
        classroom_id: c.classroom_id,
        class_type: c.class_type,
        notes: null,
      }));
      const { error: insErr } = await supabase
        .from('enrollment_classes')
        .insert(rows);
      if (insErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy enrollment classes' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }
  }

  // 3h) Update offer_letters to link to student
  {
    const { error: offerErr } = await service
      .from('offer_letters')
      .update({ student_id: student.id })
      .eq('application_id', app.id)
      .is('student_id', null);
    if (offerErr) {
      // Log but don't fail approval
      console.error('Failed to link offer letters to student:', offerErr);
      fileCopyWarnings.push(
        `Failed to link offer letters: ${offerErr.message}`
      );
    }
  }

  // 3i) Create Supabase auth user and send acceptance email with password reset link
  {
    const studentEmail = student.email;
    if (!studentEmail) {
      console.warn(
        `Student ${student.id} has no email, skipping user creation and email`
      );
    } else {
      try {
        // Use explicit site URL for the frontend, not SUPABASE_URL (54321)
        const siteUrl =
          Deno.env.get('SITE_URL') ||
          Deno.env.get('NEXT_PUBLIC_SITE_URL') ||
          'http://127.0.0.1:3000';

        const { data: linkData, error: linkErr } =
          await service.auth.admin.generateLink({
            type: 'invite',
            email: studentEmail,
            options: {
              data: {
                first_name: student.first_name,
                last_name: student.last_name,
                rto_id: app.rto_id,
                role: 'STUDENT',
                student_id: student.id,
              },
              // Route via callback so server can exchange code, then continue to update-password
              redirectTo: `${siteUrl}/auth/callback?next=/auth/update-password`,
            },
          });

        if (linkErr || !linkData?.properties?.action_link) {
          console.error('Failed to generate invite link:', linkErr);
          fileCopyWarnings.push(
            `Failed to generate invite link: ${linkErr?.message || 'Unknown error'}`
          );
        } else {
          // Get the user ID from the generated link
          const authUserId = linkData.user?.id;

          if (authUserId) {
            // Update user metadata and app_metadata
            await service.auth.admin.updateUserById(authUserId, {
              user_metadata: {
                first_name: student.first_name,
                last_name: student.last_name,
                preferred_name: student.preferred_name,
              },
              app_metadata: {
                rto_id: app.rto_id,
                role: 'STUDENT',
                student_id: student.id,
              },
            });

            // Update student record with user_id
            const { error: updateErr } = await service
              .from('students')
              .update({ user_id: authUserId })
              .eq('id', student.id);

            if (updateErr) {
              console.error('Failed to link user_id to student:', updateErr);
              fileCopyWarnings.push(
                `Failed to link user account: ${updateErr.message}`
              );
            }
          }

          // Fetch RTO name for email
          const { data: rtoInfo } = await supabase
            .from('rtos')
            .select('name')
            .eq('id', app.rto_id)
            .single();

          const rtoName = rtoInfo?.name || 'your training organisation';
          const studentName =
            student.preferred_name || student.first_name || 'Student';

          // Send acceptance email via Resend
          // Match the pattern used in daily-finance-tick: only require RESEND_API_KEY
          const resendKey = Deno.env.get('RESEND_API_KEY');
          const resendFrom = Deno.env.get('RESEND_FROM');

          // Debug logging to help diagnose Resend configuration issues
          if (!resendKey) {
            console.warn(
              'RESEND_API_KEY not found in environment variables. Available env vars:',
              Object.keys(Deno.env.toObject()).filter((k) =>
                k.toUpperCase().includes('RESEND')
              )
            );
          }

          if (resendKey) {
            const emailRes = await fetch('https://api.resend.com/emails', {
              method: 'POST',
              headers: {
                Authorization: `Bearer ${resendKey}`,
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                from: resendFrom ?? 'no-reply@example.com',
                to: studentEmail,
                subject: `Welcome to ${rtoName} - Your Application Has Been Approved`,
                html: `
                  <p>Dear ${studentName},</p>
                  <p>Congratulations! Your application has been approved and you have been accepted to ${rtoName}.</p>
                  <p>A new user account has been created for you. Please click the button below to set your password and access your student portal.</p>
                  <p><a href="${linkData.properties.action_link}" style="display:inline-block;padding:10px 16px;background:#111;color:#fff;text-decoration:none;border-radius:6px">Set Password & Access Portal</a></p>
                  <p>If the button doesn't work, copy and paste this link into your browser:</p>
                  <p><a href="${linkData.properties.action_link}">${linkData.properties.action_link}</a></p>
                  <p>Your Student ID: <strong>${student.student_id_display}</strong></p>
                  <p>Once you've set your password, you'll be able to:</p>
                  <ul>
                    <li>View your course progression</li>
                    <li>Access your assignments</li>
                    <li>View your finance and attendance records</li>
                  </ul>
                  <p>If you have any questions, please contact ${rtoName}.</p>
                  <p>— ${rtoName} Team</p>
                `,
              }),
            });

            if (!emailRes.ok) {
              const errorText = await emailRes.text();
              console.warn(
                `Email send failed for student ${student.id}:`,
                errorText
              );
              fileCopyWarnings.push(
                `Failed to send acceptance email: ${errorText}`
              );
            }
          } else {
            console.warn('Resend not configured - skipping acceptance email');
            fileCopyWarnings.push(
              'Acceptance email not sent (Resend not configured)'
            );
          }
        }
      } catch (userErr) {
        // Log but don't fail approval - user creation is important but shouldn't block approval
        console.error('Error creating user or sending email:', userErr);
        fileCopyWarnings.push(
          `User creation/email error: ${userErr instanceof Error ? userErr.message : String(userErr)}`
        );
      }
    }
  }

  // 4) Update application status to APPROVED
  // Only update if status is still ACCEPTED (prevents race conditions)
  const { error: updErr } = await supabase
    .from('applications')
    .update({ status: 'APPROVED' })
    .eq('id', app.id)
    .eq('status', 'ACCEPTED'); // Ensure atomicity - only update if still ACCEPTED
  if (updErr) {
    return new Response(
      JSON.stringify({ error: 'Failed to update application status' }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }

  // 5) Sync student to Xero as Contact (non-blocking)
  // This is done asynchronously so failures don't block application approval
  try {
    const xeroSyncUrl = `${Deno.env.get('SUPABASE_URL')}/functions/v1/xero-sync-contact`;
    fetch(xeroSyncUrl, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        Authorization: `Bearer ${Deno.env.get('SUPABASE_ANON_KEY')}`,
      },
      body: JSON.stringify({ studentId: student.id }),
    }).catch((err) => {
      // Log but don't fail - Xero sync is non-critical for approval
      console.warn('Xero contact sync failed (non-blocking):', err);
    });
    // Don't await - let it run in background
  } catch (xeroErr) {
    // Log but don't fail
    console.warn('Xero contact sync error (non-blocking):', xeroErr);
  }

  return new Response(
    JSON.stringify({
      message: 'Application approved, invoices scheduled for issue',
      studentId: student.id,
      enrollmentId: enrollment.id,
      warnings: fileCopyWarnings.length > 0 ? fileCopyWarnings : undefined,
    }),
    {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 200,
    }
  );
});
