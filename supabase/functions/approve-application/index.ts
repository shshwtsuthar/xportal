/// <reference lib="deno.ns" />

import { serve } from 'std/http/server.ts';
import { createClient } from '@supabase/supabase-js';
import { Database } from '../_shared/database.types.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
};

type Db = Database;

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    const supabase = createClient<Db>(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_ANON_KEY') ?? '',
      {
        global: {
          headers: { Authorization: req.headers.get('Authorization')! },
        },
      }
    );

    // Service role client for storage operations that bypass RLS
    const service = createClient<Db>(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { applicationId } = await req.json();
    if (!applicationId) {
      return new Response(
        JSON.stringify({ error: 'applicationId is required' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Fetch application with needed fields
    const { data: app, error: appErr } = await supabase
      .from('applications')
      .select('*')
      .eq('id', applicationId)
      .single();
    if (appErr || !app) {
      return new Response(JSON.stringify({ error: 'Application not found' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 404,
      });
    }

    if (app.status !== 'ACCEPTED') {
      return new Response(
        JSON.stringify({
          error: `Application must be ACCEPTED to approve. Current: ${app.status}`,
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 409,
        }
      );
    }

    // Determine anchor date with precedence: user-selected first, then template rule
    if (!app.payment_plan_template_id) {
      return new Response(
        JSON.stringify({
          error: 'payment_plan_template_id not set on application',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    const { data: template, error: tplErr } = await supabase
      .from('payment_plan_templates')
      .select('id')
      .eq('id', app.payment_plan_template_id)
      .single();
    if (tplErr || !template) {
      return new Response(
        JSON.stringify({ error: 'Payment plan template not found' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Anchor precedence: user-selected > commencement > offer
    let anchorDate: string | null = null;
    if (app.payment_anchor_date) {
      anchorDate = app.payment_anchor_date as string;
    } else if (app.proposed_commencement_date) {
      anchorDate = app.proposed_commencement_date as string;
    } else if (app.offer_generated_at) {
      anchorDate = new Date(app.offer_generated_at as string)
        .toISOString()
        .slice(0, 10);
    }

    if (!anchorDate) {
      return new Response(
        JSON.stringify({
          error: 'Anchor date cannot be determined for template',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Begin approval transaction using PostgREST sequential operations
    // 1) Create student
    // Note: student_id_display will be auto-generated by trigger if empty/null
    // TypeScript types mark it as required, but the database trigger handles empty strings
    const studentInsert = {
      rto_id: app.rto_id,
      application_id: app.id,
      salutation: app.salutation,
      first_name: app.first_name!,
      middle_name: app.middle_name,
      last_name: app.last_name!,
      preferred_name: app.preferred_name,
      email: app.email!,
      date_of_birth: app.date_of_birth!,
      work_phone: app.work_phone,
      mobile_phone: app.mobile_phone,
      alternative_email: app.alternative_email,
      status: 'ACTIVE',
      // Pass empty string - trigger will generate the actual display ID
      student_id_display: '',
    } as Db['public']['Tables']['students']['Insert'];

    const { data: student, error: studentErr } = await supabase
      .from('students')
      .insert(studentInsert)
      .select('*')
      .single();
    if (studentErr || !student) {
      console.error('Student creation error:', studentErr);
      return new Response(
        JSON.stringify({
          error: 'Failed to create student',
          details: studentErr?.message || 'Unknown error',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    // 1b) Copy files from applications bucket to students bucket
    const fileCopyWarnings: string[] = [];
    try {
      // Recursively list all files in the application folder
      const listFilesRecursively = async (
        bucket: string,
        prefix: string,
        files: string[] = []
      ): Promise<string[]> => {
        const { data, error } = await service.storage
          .from(bucket)
          .list(prefix, {
            limit: 1000,
            sortBy: { column: 'name', order: 'asc' },
          });

        if (error) {
          console.error(`Error listing files in ${prefix}:`, error);
          return files;
        }

        if (!data || data.length === 0) {
          return files;
        }

        for (const item of data) {
          const fullPath = prefix ? `${prefix}/${item.name}` : item.name;
          // Files have an id property, folders don't
          if (item.id) {
            // It's a file
            files.push(fullPath);
          } else {
            // It's a folder, recurse into it
            await listFilesRecursively(bucket, fullPath, files);
          }
        }

        return files;
      };

      const applicationFiles = await listFilesRecursively(
        'applications',
        app.id
      );

      // Copy each file to students bucket
      for (const filePath of applicationFiles) {
        try {
          // Download from applications bucket
          const { data: fileData, error: downloadErr } = await service.storage
            .from('applications')
            .download(filePath);

          if (downloadErr || !fileData) {
            fileCopyWarnings.push(
              `Failed to download ${filePath}: ${downloadErr?.message || 'Unknown error'}`
            );
            continue;
          }

          // Calculate relative path (remove applicationId prefix)
          const relativePath = filePath.startsWith(`${app.id}/`)
            ? filePath.slice(`${app.id}/`.length)
            : filePath;

          // Upload to students bucket
          const targetPath = `${student.id}/${relativePath}`;
          // Get content type from file extension or metadata if available
          const contentType = fileData.type || undefined;
          const { error: uploadErr } = await service.storage
            .from('students')
            .upload(targetPath, fileData, {
              contentType: contentType,
              upsert: false,
            });

          if (uploadErr) {
            fileCopyWarnings.push(
              `Failed to upload ${targetPath}: ${uploadErr.message}`
            );
          }
        } catch (fileErr) {
          fileCopyWarnings.push(
            `Error copying ${filePath}: ${fileErr instanceof Error ? fileErr.message : String(fileErr)}`
          );
        }
      }
    } catch (copyErr) {
      // Log error but don't fail approval
      console.error('Error during file copy:', copyErr);
      fileCopyWarnings.push(
        `File copy operation failed: ${copyErr instanceof Error ? copyErr.message : String(copyErr)}`
      );
    }

    // 2) Create enrollment and copy template id
    const { data: enrollment, error: enrErr } = await supabase
      .from('enrollments')
      .insert({
        student_id: student.id,
        program_id: app.program_id, // align with current schema
        rto_id: app.rto_id,
        status: 'ACTIVE',
        commencement_date: anchorDate,
        payment_plan_template_id: app.payment_plan_template_id,
      })
      .select('*')
      .single();
    if (enrErr || !enrollment) {
      return new Response(
        JSON.stringify({ error: 'Failed to create enrollment' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    // 3) Use application_payment_schedule snapshot if present; fallback to on-the-fly calc
    const { data: snapshot, error: snapErr } = await supabase
      .from('application_payment_schedule')
      .select('name, amount_cents, due_date')
      .eq('application_id', app.id)
      .order('sequence_order', { ascending: true })
      .order('due_date', { ascending: true })
      .order('name', { ascending: true });

    let invoiceRows: Db['public']['Tables']['invoices']['Insert'][] = [];
    if (!snapErr && snapshot && snapshot.length > 0) {
      invoiceRows = snapshot.map((row, idx) => {
        const isFirst = idx === 0;
        return {
          enrollment_id: enrollment.id,
          rto_id: app.rto_id,
          status: isFirst ? 'SENT' : 'SCHEDULED',
          invoice_number: crypto.randomUUID(),
          issue_date: isFirst
            ? new Date().toISOString().slice(0, 10)
            : (row.due_date as string),
          due_date: row.due_date as string,
          amount_due_cents: row.amount_cents as number,
          amount_paid_cents: 0,
        } as Db['public']['Tables']['invoices']['Insert'];
      });
    } else {
      // Fallback: compute based on template installments and anchor
      const { data: installments, error: instErr } = await supabase
        .from('payment_plan_template_installments')
        .select('id, name, amount_cents, due_date_rule_days')
        .eq('template_id', template.id)
        .order('due_date_rule_days', { ascending: true });
      if (instErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to read installments' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
      const anchor = new Date(anchorDate);
      invoiceRows = (installments ?? []).map((i, idx) => {
        const due = new Date(anchor);
        due.setDate(due.getDate() + Number(i.due_date_rule_days));
        const dueDateStr = due.toISOString().slice(0, 10);
        const isFirst = idx === 0;
        return {
          enrollment_id: enrollment.id,
          rto_id: app.rto_id,
          status: isFirst ? 'SENT' : 'SCHEDULED',
          invoice_number: crypto.randomUUID(),
          issue_date: isFirst
            ? new Date().toISOString().slice(0, 10)
            : dueDateStr,
          due_date: dueDateStr,
          amount_due_cents: i.amount_cents,
          amount_paid_cents: 0,
        } as Db['public']['Tables']['invoices']['Insert'];
      });
    }

    if (invoiceRows.length > 0) {
      const { error: invErr } = await supabase
        .from('invoices')
        .insert(invoiceRows);
      if (invErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to create invoices' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // --- Extended copy: student domain normalization ---
    // 3b) Addresses (street + postal)
    {
      const street = {
        student_id: student.id,
        rto_id: app.rto_id,
        type: 'street',
        building_name: app.street_building_name,
        unit_details: app.street_unit_details,
        number_name: app.street_number_name,
        po_box: app.street_po_box,
        suburb: app.suburb,
        state: app.state,
        postcode: app.postcode,
        country: app.street_country,
        is_primary: true,
      } as const;
      const postal = app.postal_is_same_as_street
        ? null
        : {
            student_id: student.id,
            rto_id: app.rto_id,
            type: 'postal',
            building_name: app.postal_building_name,
            unit_details: app.postal_unit_details,
            number_name: app.postal_number_name,
            po_box: app.postal_po_box,
            suburb: app.postal_suburb,
            state: app.postal_state,
            postcode: app.postal_postcode,
            country: app.postal_country,
            is_primary: false,
          };
      const addrRows = [street, postal].filter(
        Boolean
      ) as Db['public']['Tables']['student_addresses']['Insert'][];
      if (addrRows.length > 0) {
        const { error: addrErr } = await supabase
          .from('student_addresses')
          .insert(addrRows);
        if (addrErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy student addresses' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 3c) AVETMISS snapshot
    {
      const { error: avErr } = await supabase.from('student_avetmiss').insert({
        student_id: student.id,
        rto_id: app.rto_id,
        gender: app.gender,
        highest_school_level_id: app.highest_school_level_id,
        year_highest_school_level_completed:
          app.year_highest_school_level_completed,
        indigenous_status_id: app.indigenous_status_id,
        labour_force_status_id: app.labour_force_status_id,
        country_of_birth_id: app.country_of_birth_id,
        language_code: app.language_code,
        citizenship_status_code: app.citizenship_status_code,
        at_school_flag: app.at_school_flag,
        disability_flag: app.disability_flag || null,
        prior_education_flag: app.prior_education_flag || null,
        survey_contact_status: app.survey_contact_status || 'A',
        vsn: app.vsn || null,
        usi: app.usi || null,
      });
      if (avErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy AVETMISS details' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // 3c1) Copy disabilities from application to student
    {
      const { data: appDisabilities, error: fetchErr } = await supabase
        .from('application_disabilities')
        .select('disability_type_id')
        .eq('application_id', app.id);

      if (fetchErr) {
        console.error('Error fetching application disabilities:', fetchErr);
        return new Response(
          JSON.stringify({ error: 'Failed to fetch application disabilities' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }

      if (appDisabilities && appDisabilities.length > 0) {
        const studentDisabilities = appDisabilities.map((d) => ({
          student_id: student.id,
          rto_id: app.rto_id,
          disability_type_id: d.disability_type_id,
        }));

        const { error: disErr } = await supabase
          .from('student_disabilities')
          .insert(studentDisabilities);
        if (disErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy disabilities' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 3c2) Copy prior education from application to student
    {
      const { data: appPriorEd, error: fetchErr } = await supabase
        .from('application_prior_education')
        .select('prior_achievement_id, recognition_type')
        .eq('application_id', app.id);

      if (fetchErr) {
        console.error('Error fetching application prior education:', fetchErr);
        return new Response(
          JSON.stringify({
            error: 'Failed to fetch application prior education',
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }

      if (appPriorEd && appPriorEd.length > 0) {
        const studentPriorEd = appPriorEd.map((e) => ({
          student_id: student.id,
          rto_id: app.rto_id,
          prior_achievement_id: e.prior_achievement_id,
          recognition_type: e.recognition_type || null,
        }));

        const { error: priorEdErr } = await supabase
          .from('student_prior_education')
          .insert(studentPriorEd);
        if (priorEdErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy prior education' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 3d) CRICOS snapshot
    {
      const { error: crErr } = await supabase.from('student_cricos').insert({
        student_id: student.id,
        rto_id: app.rto_id,
        is_international: Boolean(app.is_international),
        passport_number: app.passport_number,
        passport_issue_date: app.passport_issue_date,
        passport_expiry_date: app.passport_expiry_date,
        place_of_birth: app.place_of_birth,
        visa_type: app.visa_type,
        visa_number: app.visa_number,
        visa_application_office: app.visa_application_office,
        country_of_citizenship: app.country_of_citizenship,
        is_under_18: app.is_under_18,
        provider_accepting_welfare_responsibility:
          app.provider_accepting_welfare_responsibility,
        welfare_start_date: app.welfare_start_date,
        provider_arranged_oshc: app.provider_arranged_oshc,
        oshc_provider_name: app.oshc_provider_name,
        oshc_start_date: app.oshc_start_date,
        oshc_end_date: app.oshc_end_date,
        has_english_test: app.has_english_test,
        english_test_type: app.english_test_type,
        english_test_date: app.english_test_date,
        ielts_score: app.ielts_score,
        has_previous_study_australia: app.has_previous_study_australia,
        previous_provider_name: app.previous_provider_name,
        completed_previous_course: app.completed_previous_course,
        has_release_letter: app.has_release_letter,
      });
      if (crErr) {
        return new Response(
          JSON.stringify({ error: 'Failed to copy CRICOS details' }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // 3e) Emergency and guardian contacts
    {
      const inserts: Db['public']['Tables']['student_contacts_emergency']['Insert'][] =
        [];
      if (app.ec_name || app.ec_phone_number || app.ec_relationship) {
        inserts.push({
          student_id: student.id,
          rto_id: app.rto_id,
          name: app.ec_name,
          relationship: app.ec_relationship,
          phone_number: app.ec_phone_number,
        });
      }
      if (inserts.length > 0) {
        const { error: ecErr } = await supabase
          .from('student_contacts_emergency')
          .insert(inserts);
        if (ecErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy emergency contacts' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
      if (app.g_name || app.g_email || app.g_phone_number) {
        const { error: gErr } = await supabase
          .from('student_contacts_guardians')
          .insert({
            student_id: student.id,
            rto_id: app.rto_id,
            name: app.g_name,
            email: app.g_email,
            phone_number: app.g_phone_number,
            relationship: app.g_relationship,
          });
        if (gErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy guardian contact' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 3f) Learning plan subjects → enrollment_subjects
    {
      const { data: subjects, error: subjErr } = await supabase
        .from('application_learning_subjects')
        .select(
          'program_plan_subject_id, subject_id, planned_start_date, planned_end_date, is_catch_up, is_prerequisite'
        )
        .eq('application_id', app.id)
        .order('sequence_order', { ascending: true });
      if (!subjErr && subjects && subjects.length > 0) {
        const rows = subjects.map(
          (
            s: Db['public']['Tables']['application_learning_subjects']['Row']
          ) => ({
            enrollment_id: enrollment.id,
            program_plan_subject_id: s.program_plan_subject_id,
            outcome_code: null,
            start_date: s.planned_start_date,
            end_date: s.planned_end_date,
            is_catch_up: s.is_catch_up,
            delivery_location_id: null,
            delivery_mode_id: null,
            scheduled_hours: null,
          })
        );
        const { error: insErr } = await supabase
          .from('enrollment_subjects')
          .insert(rows);
        if (insErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy enrollment subjects' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 3g) Learning plan classes → enrollment_classes
    {
      const { data: classes, error: clsErr } = await supabase
        .from('application_learning_classes')
        .select(
          'program_plan_class_id, class_date, start_time, end_time, trainer_id, location_id, classroom_id, class_type'
        )
        .eq('application_id', app.id);
      if (!clsErr && classes && classes.length > 0) {
        const rows = classes.map(
          (
            c: Db['public']['Tables']['application_learning_classes']['Row']
          ) => ({
            enrollment_id: enrollment.id,
            program_plan_class_id: c.program_plan_class_id,
            class_date: c.class_date,
            start_time: c.start_time,
            end_time: c.end_time,
            trainer_id: c.trainer_id,
            location_id: c.location_id,
            classroom_id: c.classroom_id,
            class_type: c.class_type,
            notes: null,
          })
        );
        const { error: insErr } = await supabase
          .from('enrollment_classes')
          .insert(rows);
        if (insErr) {
          return new Response(
            JSON.stringify({ error: 'Failed to copy enrollment classes' }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 3h) Update offer_letters to link to student
    {
      const { error: offerErr } = await service
        .from('offer_letters')
        .update({ student_id: student.id })
        .eq('application_id', app.id)
        .is('student_id', null);
      if (offerErr) {
        // Log but don't fail approval
        console.error('Failed to link offer letters to student:', offerErr);
        fileCopyWarnings.push(
          `Failed to link offer letters: ${offerErr.message}`
        );
      }
    }

    // 4) Update application status to APPROVED
    const { error: updErr } = await supabase
      .from('applications')
      .update({ status: 'APPROVED' })
      .eq('id', app.id);
    if (updErr) {
      return new Response(
        JSON.stringify({ error: 'Failed to update application status' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    return new Response(
      JSON.stringify({
        message: 'Application approved, invoices generated',
        studentId: student.id,
        enrollmentId: enrollment.id,
        warnings: fileCopyWarnings.length > 0 ? fileCopyWarnings : undefined,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (e) {
    const msg = e instanceof Error ? e.message : String(e);
    return new Response(JSON.stringify({ error: msg }), {
      headers: { ...corsHeaders, 'Content-Type': 'application/json' },
      status: 500,
    });
  }
});
