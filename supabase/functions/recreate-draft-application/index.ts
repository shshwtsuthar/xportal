/// <reference lib="deno.ns" />

import { serve } from 'std/http/server.ts';
import { createClient } from '@supabase/supabase-js';
import { Database } from '../_shared/database.types.ts';

const corsHeaders = {
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type',
};

type Db = Database;

/**
 * Helper function to recursively list all files in a storage bucket folder
 */
async function listFilesRecursively(
  bucket: string,
  prefix: string,
  service: ReturnType<typeof createClient<Db>>,
  files: string[] = []
): Promise<string[]> {
  const { data, error } = await service.storage.from(bucket).list(prefix, {
    limit: 1000,
    sortBy: { column: 'name', order: 'asc' },
  });

  if (error) {
    console.error(`Error listing files in ${prefix}:`, error);
    return files;
  }

  if (!data || data.length === 0) {
    return files;
  }

  for (const item of data) {
    const fullPath = prefix ? `${prefix}/${item.name}` : item.name;
    // Files have an id property, folders don't
    if (item.id) {
      // It's a file
      files.push(fullPath);
    } else {
      // It's a folder, recurse into it
      await listFilesRecursively(bucket, fullPath, service, files);
    }
  }

  return files;
}

serve(async (req: Request) => {
  if (req.method === 'OPTIONS') {
    return new Response('ok', { headers: corsHeaders });
  }

  try {
    // Use service role client to bypass RLS for all operations
    const service = createClient<Db>(
      Deno.env.get('SUPABASE_URL') ?? '',
      Deno.env.get('SUPABASE_SERVICE_ROLE_KEY') ?? ''
    );

    const { applicationId } = await req.json();
    if (!applicationId) {
      return new Response(
        JSON.stringify({ error: 'applicationId is required' }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 400,
        }
      );
    }

    // Fetch the original application
    const { data: originalApp, error: appErr } = await service
      .from('applications')
      .select('*')
      .eq('id', applicationId)
      .single();

    if (appErr || !originalApp) {
      return new Response(JSON.stringify({ error: 'Application not found' }), {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 404,
      });
    }

    // Prepare new application data (exclude id, created_at, updated_at, status, application_id_display)
    // These will be set automatically by the database
    const {
      id: _id,
      created_at: _created_at,
      updated_at: _updated_at,
      status: _status,
      application_id_display: _display_id,
      ...appDataToCopy
    } = originalApp;

    // Create new application with status DRAFT
    // created_at and updated_at will be set to current timestamp
    // application_id_display will be auto-generated by trigger
    const { data: newApp, error: newAppErr } = await service
      .from('applications')
      .insert({
        ...appDataToCopy,
        status: 'DRAFT',
        // created_at and updated_at will be set automatically by database defaults
      } as Db['public']['Tables']['applications']['Insert'])
      .select('*')
      .single();

    if (newAppErr || !newApp) {
      console.error('Failed to create new application:', newAppErr);
      return new Response(
        JSON.stringify({
          error: 'Failed to create new application',
          details: newAppErr?.message || 'Unknown error',
        }),
        {
          headers: { ...corsHeaders, 'Content-Type': 'application/json' },
          status: 500,
        }
      );
    }

    // 1. Duplicate application_disabilities
    const { data: disabilities, error: disErr } = await service
      .from('application_disabilities')
      .select('*')
      .eq('application_id', applicationId);

    if (!disErr && disabilities && disabilities.length > 0) {
      const disabilitiesToInsert = disabilities.map((d) => ({
        application_id: newApp.id,
        rto_id: d.rto_id,
        disability_type_id: d.disability_type_id,
      }));

      const { error: insertDisErr } = await service
        .from('application_disabilities')
        .insert(disabilitiesToInsert);

      if (insertDisErr) {
        console.error('Failed to duplicate disabilities:', insertDisErr);
        return new Response(
          JSON.stringify({
            error: 'Failed to duplicate application disabilities',
            details: insertDisErr.message,
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // 2. Duplicate application_prior_education
    const { data: priorEd, error: priorEdErr } = await service
      .from('application_prior_education')
      .select('*')
      .eq('application_id', applicationId);

    if (!priorEdErr && priorEd && priorEd.length > 0) {
      const priorEdToInsert = priorEd.map((pe) => ({
        application_id: newApp.id,
        rto_id: pe.rto_id,
        prior_achievement_id: pe.prior_achievement_id,
      }));

      const { error: insertPriorEdErr } = await service
        .from('application_prior_education')
        .insert(priorEdToInsert);

      if (insertPriorEdErr) {
        console.error('Failed to duplicate prior education:', insertPriorEdErr);
        return new Response(
          JSON.stringify({
            error: 'Failed to duplicate application prior education',
            details: insertPriorEdErr.message,
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // 3. Duplicate application_learning_subjects (must be done before classes)
    const { data: learningSubjects, error: subjectsErr } = await service
      .from('application_learning_subjects')
      .select('*')
      .eq('application_id', applicationId);

    // Map old subject IDs to new subject IDs for classes
    const subjectIdMap = new Map<string, string>();

    if (!subjectsErr && learningSubjects && learningSubjects.length > 0) {
      for (const subject of learningSubjects) {
        const { id: oldSubjectId, ...subjectData } = subject;
        const { data: newSubject, error: insertSubjectErr } = await service
          .from('application_learning_subjects')
          .insert({
            ...subjectData,
            application_id: newApp.id,
          } as Db['public']['Tables']['application_learning_subjects']['Insert'])
          .select('id')
          .single();

        if (insertSubjectErr || !newSubject) {
          console.error(
            'Failed to duplicate learning subject:',
            insertSubjectErr
          );
          return new Response(
            JSON.stringify({
              error: 'Failed to duplicate application learning subjects',
              details: insertSubjectErr?.message || 'Unknown error',
            }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }

        subjectIdMap.set(oldSubjectId, newSubject.id);
      }
    }

    // 4. Duplicate application_learning_classes (depends on subjects)
    const { data: learningClasses, error: classesErr } = await service
      .from('application_learning_classes')
      .select('*')
      .eq('application_id', applicationId);

    if (!classesErr && learningClasses && learningClasses.length > 0) {
      const classesToInsert = learningClasses
        .map((cls) => {
          const newSubjectId = subjectIdMap.get(
            cls.application_learning_subject_id
          );
          if (!newSubjectId) {
            console.warn(
              `Could not find new subject ID for old subject ID: ${cls.application_learning_subject_id}`
            );
            return null;
          }
          const { id: _id, ...classData } = cls;
          return {
            ...classData,
            application_id: newApp.id,
            application_learning_subject_id: newSubjectId,
          };
        })
        .filter((cls): cls is NonNullable<typeof cls> => cls !== null);

      if (classesToInsert.length > 0) {
        const { error: insertClassesErr } = await service
          .from('application_learning_classes')
          .insert(classesToInsert);

        if (insertClassesErr) {
          console.error(
            'Failed to duplicate learning classes:',
            insertClassesErr
          );
          return new Response(
            JSON.stringify({
              error: 'Failed to duplicate application learning classes',
              details: insertClassesErr.message,
            }),
            {
              headers: { ...corsHeaders, 'Content-Type': 'application/json' },
              status: 500,
            }
          );
        }
      }
    }

    // 5. Duplicate application_payment_schedule
    const { data: paymentSchedule, error: paymentErr } = await service
      .from('application_payment_schedule')
      .select('*')
      .eq('application_id', applicationId);

    if (!paymentErr && paymentSchedule && paymentSchedule.length > 0) {
      const paymentToInsert = paymentSchedule.map((ps) => {
        const { id: _id, ...paymentData } = ps;
        return {
          ...paymentData,
          application_id: newApp.id,
        };
      });

      const { error: insertPaymentErr } = await service
        .from('application_payment_schedule')
        .insert(paymentToInsert);

      if (insertPaymentErr) {
        console.error(
          'Failed to duplicate payment schedule:',
          insertPaymentErr
        );
        return new Response(
          JSON.stringify({
            error: 'Failed to duplicate application payment schedule',
            details: insertPaymentErr.message,
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // 6. Duplicate offer_letters
    const { data: offerLetters, error: offerErr } = await service
      .from('offer_letters')
      .select('*')
      .eq('application_id', applicationId);

    if (!offerErr && offerLetters && offerLetters.length > 0) {
      const offersToInsert = offerLetters.map((ol) => {
        const { id: _id, ...offerData } = ol;
        return {
          ...offerData,
          application_id: newApp.id,
          // student_id should remain NULL for the new draft application
          student_id: null,
        };
      });

      const { error: insertOfferErr } = await service
        .from('offer_letters')
        .insert(offersToInsert);

      if (insertOfferErr) {
        console.error('Failed to duplicate offer letters:', insertOfferErr);
        return new Response(
          JSON.stringify({
            error: 'Failed to duplicate offer letters',
            details: insertOfferErr.message,
          }),
          {
            headers: { ...corsHeaders, 'Content-Type': 'application/json' },
            status: 500,
          }
        );
      }
    }

    // 7. Duplicate files from storage bucket
    const fileCopyWarnings: string[] = [];
    try {
      const applicationFiles = await listFilesRecursively(
        'applications',
        applicationId,
        service
      );

      // Copy each file to the new application folder
      for (const filePath of applicationFiles) {
        try {
          // Download from original application folder
          const { data: fileData, error: downloadErr } = await service.storage
            .from('applications')
            .download(filePath);

          if (downloadErr || !fileData) {
            fileCopyWarnings.push(
              `Failed to download ${filePath}: ${downloadErr?.message || 'Unknown error'}`
            );
            continue;
          }

          // Calculate relative path (remove applicationId prefix)
          const relativePath = filePath.startsWith(`${applicationId}/`)
            ? filePath.slice(`${applicationId}/`.length)
            : filePath;

          // Upload to new application folder
          const targetPath = `${newApp.id}/${relativePath}`;
          const contentType = fileData.type || undefined;
          const { error: uploadErr } = await service.storage
            .from('applications')
            .upload(targetPath, fileData, {
              contentType: contentType,
              upsert: false,
            });

          if (uploadErr) {
            fileCopyWarnings.push(
              `Failed to upload ${targetPath}: ${uploadErr.message}`
            );
          }
        } catch (fileErr) {
          fileCopyWarnings.push(
            `Error copying ${filePath}: ${fileErr instanceof Error ? fileErr.message : String(fileErr)}`
          );
        }
      }
    } catch (copyErr) {
      // Log error but don't fail the operation
      console.error('Error during file copy:', copyErr);
      fileCopyWarnings.push(
        `File copy operation failed: ${copyErr instanceof Error ? copyErr.message : String(copyErr)}`
      );
    }

    // Return success response with warnings if any
    return new Response(
      JSON.stringify({
        success: true,
        newApplicationId: newApp.id,
        newApplicationDisplayId: newApp.application_id_display,
        warnings: fileCopyWarnings.length > 0 ? fileCopyWarnings : undefined,
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 200,
      }
    );
  } catch (error) {
    console.error('Unexpected error:', error);
    return new Response(
      JSON.stringify({
        error: 'Internal server error',
        details: error instanceof Error ? error.message : String(error),
      }),
      {
        headers: { ...corsHeaders, 'Content-Type': 'application/json' },
        status: 500,
      }
    );
  }
});
